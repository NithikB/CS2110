#include "main.h"
#include "images/startScreen.h"
#include "images/pac.h"
#include "images/winScreen.h"
#include "images/cube.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  INITPLAY,
  PLAY,
  WIN,
  RESTART,
};

char buffer[51];

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //

  REG_DISPCNT = MODE3 | BG2_ENABLE; //Mode 3 and BG2

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  struct pacData curPac, oldPac;
  curPac.x = 108;
  curPac.y = 120;
  oldPac = curPac;

  int cubeX = randint(0, 200);
  int moves = 0;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();

    switch (state) {
      case START:
        drawFullScreenImageDMA(startScreen);
        cubeX = randint(0, 200);
        curPac.x = 108;
        curPac.y = 120;
        moves = 0;
        oldPac = curPac;
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons))
            state = INITPLAY;
        break;
      case INITPLAY:
        fillScreenDMA(BLUE);
        drawImageDMA(10, cubeX, GLOWCUBE_WIDTH, GLOWCUBE_HEIGHT, glowcube);
        drawImageDMA(curPac.y, curPac.x, PACMAN_WIDTH, PACMAN_HEIGHT, pacman);
        state = PLAY;
        break;
      case PLAY:
        sprintf(buffer, "Moves: %d", moves);
        drawRectDMA(150, 5, 200, 10, BLUE);
        drawString(150, 5, buffer, GREEN);
        drawRectDMA(oldPac.y, oldPac.x, 25, 25, BLUE);
        drawImageDMA(curPac.y, curPac.x, PACMAN_WIDTH, PACMAN_HEIGHT, pacman);
        oldPac = curPac;
        if ((curPac.x > cubeX - 25) && (curPac.x < cubeX + 40) && (curPac.y < 50) && (curPac.y + 25 > 10)) {
           state = WIN;
           break;
        }
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
           state = RESTART;
        if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
           curPac.y -= 5;
           moves++;
           if (curPac.y < 0)
              curPac.y = 0;
        }
        if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)) {
           curPac.y += 5;
           moves++;
           if (curPac.y + 25 > 160)
               curPac.y = 135;
        }
        if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons)) {
           curPac.x -= 5;
           moves++;
           if (curPac.x < 0)
              curPac.x = 0;
        }
        if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons)) {
           curPac.x += 5;
           moves++;
           if (curPac.x + 25 > 240)
              curPac.x = 215;
        }
        break;
      case WIN:
        drawFullScreenImageDMA(winScreen);
        waitForVBlank();
        drawString(100, (240 - 8 * 6) / 2, "RESTART?", GREEN);
        drawString(110, (240 - 15 * 6) / 2, "PRESS BACKSPACE", GREEN);
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
            state = START;
        break;
      case RESTART:
        drawString(80, (240 - 9 * 6) / 2, "RESTART?", GREEN);
        drawString(90, (240 - 28 * 6) / 2, "NO - ENTER | YES - BACKSPACE", GREEN);
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
            state = START;
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
            state = PLAY;
            drawString(80, (240 - 9 * 6) / 2, "RESTART?", BLUE);
            drawString(90, (240 - 28 * 6) / 2, "NO - ENTER | YES - BACKSPACE", BLUE);
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
